#include <FastGPIO.h>

// 4 LSB bits of PORTC are used to select line address (pin A3~A0)
enum { PANEL_WIDTH = 128, PANEL_HEIGHT = 32, PANEL_HEIGHT_HALF = PANEL_HEIGHT >> 1, LAT = 10, OE = 9, CLK = 8, CR1 = 2, CG1 = 3, CB1 = 4, CR2 = 5, CG2 = 6, CB2 = 7 };
#define SETO(pin, val) FastGPIO::Pin<pin>::setOutput(val)   // set pin as output w/ value
#define OUT0(pin) FastGPIO::Pin<pin>::setOutputValueLow() 
#define OUT1(pin) FastGPIO::Pin<pin>::setOutputValueHigh()
#define OUT(pin, val) val ? OUT1(pin) : OUT0(pin)

// two pixels by byte (0x_RGB_RGB)
const uint8_t bufPacL0[] PROGMEM = { // height=15, width=7
    0x00, 0x00, 0x06, 0x66, 0x60, 0x00, 0x00
  , 0x00, 0x06, 0x66, 0x66, 0x66, 0x60, 0x00
  , 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00
  , 0x06, 0x66, 0x66, 0x66, 0x66, 0x66, 0x60
  , 0x06, 0x66, 0x66, 0x66, 0x66, 0x66, 0x60
  , 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66
  , 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66
  , 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66
  , 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66
  , 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66
  , 0x06, 0x66, 0x66, 0x66, 0x66, 0x66, 0x60
  , 0x06, 0x66, 0x66, 0x66, 0x66, 0x66, 0x60
  , 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00
  , 0x00, 0x06, 0x66, 0x66, 0x66, 0x60, 0x00
  , 0x00, 0x00, 0x06, 0x66, 0x60, 0x00, 0x00 };
#define BUFPACL0(x, y, buf) { 15, 14, x, y, 0, 0, 0, buf }
  
const uint8_t bufPacL1[] PROGMEM = { // height=15, width=7
     0x00, 0x00, 0x06, 0x66, 0x60, 0x00, 0x00
   , 0x00, 0x06, 0x66, 0x66, 0x66, 0x60, 0x00
   , 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00
   , 0x06, 0x66, 0x66, 0x66, 0x66, 0x66, 0x60
   , 0x06, 0x66, 0x66, 0x66, 0x66, 0x66, 0x60
   , 0x00, 0x06, 0x66, 0x66, 0x66, 0x66, 0x66
   , 0x00, 0x00, 0x06, 0x66, 0x66, 0x66, 0x66
   , 0x00, 0x00, 0x00, 0x06, 0x66, 0x66, 0x66
   , 0x00, 0x00, 0x06, 0x66, 0x66, 0x66, 0x66
   , 0x00, 0x06, 0x66, 0x66, 0x66, 0x66, 0x66
   , 0x06, 0x66, 0x66, 0x66, 0x66, 0x66, 0x60
   , 0x06, 0x66, 0x66, 0x66, 0x66, 0x66, 0x60
   , 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00
   , 0x00, 0x06, 0x66, 0x66, 0x66, 0x60, 0x00
   , 0x00, 0x00, 0x06, 0x66, 0x60, 0x00, 0x00 };
   
const uint8_t bufPacL2[] PROGMEM = { // height=15, width=7
     0x00, 0x00, 0x06, 0x66, 0x60, 0x00, 0x00
   , 0x00, 0x06, 0x66, 0x66, 0x66, 0x60, 0x00
   , 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00
   , 0x00, 0x06, 0x66, 0x66, 0x66, 0x66, 0x60
   , 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x60
   , 0x00, 0x00, 0x06, 0x66, 0x66, 0x66, 0x66
   , 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66
   , 0x00, 0x00, 0x00, 0x06, 0x66, 0x66, 0x66
   , 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66
   , 0x00, 0x00, 0x06, 0x66, 0x66, 0x66, 0x66
   , 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x60
   , 0x00, 0x06, 0x66, 0x66, 0x66, 0x66, 0x60
   , 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00
   , 0x00, 0x06, 0x66, 0x66, 0x66, 0x60, 0x00
   , 0x00, 0x00, 0x06, 0x66, 0x60, 0x00, 0x00 };

const uint8_t monsterLcyan[] PROGMEM = { // height=14, width=7
     0x00, 0x00, 0x03, 0x33, 0x30, 0x00, 0x00
   , 0x00, 0x03, 0x33, 0x33, 0x33, 0x30, 0x00
   , 0x00, 0x33, 0x33, 0x33, 0x33, 0x33, 0x00
   , 0x03, 0x77, 0x33, 0x33, 0x77, 0x33, 0x30
   , 0x07, 0x77, 0x73, 0x37, 0x77, 0x73, 0x30
   , 0x01, 0x17, 0x73, 0x31, 0x17, 0x73, 0x30
   , 0x31, 0x17, 0x73, 0x31, 0x17, 0x73, 0x33
   , 0x33, 0x77, 0x33, 0x33, 0x77, 0x33, 0x33
   , 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33
   , 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33
   , 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33
   , 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33
   , 0x33, 0x03, 0x33, 0x00, 0x33, 0x00, 0x33
   , 0x30, 0x00, 0x33, 0x00, 0x30, 0x00, 0x03 };
#define MONSTERLCYAN(x, y, buf) { 14, 14, x, y, 0, 0, 0, buf }

const uint8_t bubble01[] PROGMEM = { // height=16, width(real image)=16 , width(buffer)=8
     0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x66, 0x60, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x22, 0x22, 0x26, 0x66, 0x60, 0x00
   , 0x00, 0x02, 0x22, 0x22, 0x22, 0x66, 0x00, 0x00
   , 0x00, 0x27, 0x27, 0x72, 0x22, 0x20, 0x00, 0x00
   , 0x00, 0x70, 0x20, 0x77, 0x22, 0x26, 0x66, 0x00
   , 0x00, 0x70, 0x20, 0x77, 0x22, 0x22, 0x60, 0x00
   , 0x02, 0x70, 0x20, 0x77, 0x66, 0x22, 0x00, 0x00
   , 0x06, 0x70, 0x20, 0x77, 0x66, 0x62, 0x66, 0x00
   , 0x02, 0x27, 0x27, 0x72, 0x60, 0x22, 0x60, 0x00
   , 0x00, 0x00, 0x70, 0x00, 0x02, 0x42, 0x00, 0x00
   , 0x00, 0x22, 0x22, 0x22, 0x24, 0x44, 0x20, 0x00
   , 0x00, 0x07, 0x77, 0x72, 0x24, 0x44, 0x20, 0x00
   , 0x00, 0x77, 0x77, 0x77, 0x22, 0x44, 0x26, 0x00
   , 0x00, 0x77, 0x77, 0x44, 0x42, 0x22, 0x22, 0x60
   , 0x44, 0x47, 0x74, 0x44, 0x44, 0x22, 0x22, 0x22 };
#define BUBBLE01(x, y, buf) { 16, 16, x, y, 0, 0, 0, buf }

const uint8_t bubble02[] PROGMEM = { // height=16, width(real image)=16 , width(buffer)=8
     0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x66, 0x60, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x33, 0x33, 0x36, 0x66, 0x60, 0x00
   , 0x00, 0x03, 0x33, 0x33, 0x33, 0x66, 0x00, 0x00
   , 0x00, 0x37, 0x37, 0x73, 0x33, 0x30, 0x00, 0x00
   , 0x00, 0x70, 0x30, 0x77, 0x33, 0x36, 0x66, 0x00
   , 0x00, 0x70, 0x30, 0x77, 0x33, 0x33, 0x60, 0x00
   , 0x03, 0x70, 0x30, 0x77, 0x66, 0x33, 0x00, 0x00
   , 0x06, 0x70, 0x30, 0x77, 0x66, 0x63, 0x66, 0x00
   , 0x03, 0x37, 0x37, 0x73, 0x60, 0x33, 0x60, 0x00
   , 0x00, 0x00, 0x70, 0x00, 0x03, 0x43, 0x00, 0x00
   , 0x00, 0x33, 0x33, 0x33, 0x34, 0x44, 0x30, 0x00
   , 0x00, 0x07, 0x77, 0x73, 0x34, 0x44, 0x30, 0x00
   , 0x00, 0x77, 0x77, 0x77, 0x33, 0x44, 0x36, 0x00
   , 0x00, 0x77, 0x77, 0x44, 0x43, 0x33, 0x33, 0x60
   , 0x44, 0x47, 0x74, 0x44, 0x44, 0x33, 0x33, 0x33 };
#define BUBBLE02(x, y, buf) { 16, 16, x, y, 0, 0, 0, buf }

const uint8_t potion[] PROGMEM = { // height=29, width(real image)=24 , width(buffer)=12
     0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x66, 0x40, 0x00, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x66, 0x40, 0x00, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x00, 0x04, 0x44, 0x66, 0x40, 0x00, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x00, 0x66, 0x77, 0x77, 0x77, 0x77, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x00, 0x77, 0x77, 0x77, 0x77, 0x77, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x11, 0x00, 0x01, 0x01, 0x77, 0x77, 0x00, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x33, 0x11, 0x00, 0x00
   , 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x33, 0x11, 0x10, 0x00
   , 0x00, 0x00, 0x11, 0x11, 0x77, 0x77, 0x11, 0x77, 0x11, 0x33, 0x11, 0x00
   , 0x00, 0x00, 0x11, 0x11, 0x77, 0x77, 0x11, 0x77, 0x11, 0x33, 0x11, 0x10
   , 0x00, 0x11, 0x11, 0x77, 0x11, 0x11, 0x77, 0x11, 0x11, 0x33, 0x33, 0x11
   , 0x00, 0x11, 0x11, 0x77, 0x11, 0x11, 0x77, 0x11, 0x11, 0x33, 0x33, 0x11
   , 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x33, 0x33, 0x11
   , 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x33, 0x33, 0x11
   , 0x00, 0x11, 0x11, 0x11, 0x77, 0x77, 0x11, 0x77, 0x11, 0x33, 0x11, 0x11
   , 0x00, 0x11, 0x11, 0x11, 0x77, 0x77, 0x11, 0x77, 0x11, 0x33, 0x11, 0x11
   , 0x00, 0x11, 0x11, 0x77, 0x11, 0x11, 0x77, 0x11, 0x11, 0x11, 0x11, 0x11
   , 0x00, 0x11, 0x11, 0x77, 0x11, 0x11, 0x77, 0x11, 0x11, 0x11, 0x11, 0x11
   , 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x10
   , 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00 };
#define POTION(x, y, buf) { 29, 24, x, y, 0, 0, 0, buf }

const uint8_t hero[] PROGMEM = { // height=17, width(real image)=10 , width(buffer)=5
     0x00, 0x00, 0x06, 0x66, 0x66
   , 0x00, 0x00, 0x00, 0x06, 0x00
   , 0x04, 0x44, 0x00, 0x06, 0x00
   , 0x00, 0x00, 0x40, 0x04, 0x00
   , 0x04, 0x44, 0x40, 0x04, 0x00
   , 0x00, 0x44, 0x00, 0x04, 0x00
   , 0x00, 0x03, 0x30, 0x03, 0x33
   , 0x00, 0x33, 0x33, 0x33, 0x33
   , 0x00, 0x33, 0x00, 0x33, 0x30
   , 0x03, 0x03, 0x00, 0x33, 0x00
   , 0x00, 0x00, 0x00, 0x33, 0x00
   , 0x00, 0x00, 0x77, 0x70, 0x00
   , 0x00, 0x00, 0x77, 0x00, 0x00
   , 0x00, 0x00, 0x07, 0x00, 0x00
   , 0x00, 0x00, 0x07, 0x70, 0x00
   , 0x00, 0x00, 0x00, 0x70, 0x00
   , 0x00, 0x00, 0x00, 0x70, 0x00 };
#define HERO(x, y, buf) { 17, 10, x, y, 0, 0, 0, buf }

const uint8_t hero1[] PROGMEM = { // height=17, width(real image)=10 , width(buffer)=5
     0x00, 0x00, 0x00, 0x66, 0x00
   , 0x00, 0x00, 0x00, 0x06, 0x00
   , 0x04, 0x44, 0x00, 0x06, 0x00
   , 0x00, 0x00, 0x40, 0x04, 0x00
   , 0x04, 0x44, 0x40, 0x04, 0x00
   , 0x00, 0x44, 0x00, 0x04, 0x00
   , 0x00, 0x03, 0x30, 0x03, 0x33
   , 0x00, 0x33, 0x33, 0x33, 0x33
   , 0x00, 0x33, 0x00, 0x33, 0x30
   , 0x03, 0x03, 0x00, 0x33, 0x00
   , 0x00, 0x00, 0x00, 0x33, 0x00
   , 0x00, 0x00, 0x77, 0x70, 0x00
   , 0x00, 0x00, 0x77, 0x00, 0x00
   , 0x00, 0x00, 0x07, 0x00, 0x00
   , 0x00, 0x00, 0x07, 0x70, 0x00
   , 0x00, 0x00, 0x00, 0x70, 0x00
   , 0x00, 0x00, 0x00, 0x70, 0x00 };
#define HERO1(x, y, buf) { 17, 10, x, y, 0, 0, 0, buf }

const uint8_t disk7[] PROGMEM = { // height=26, width(real image)=26 , width(buffer)=13
     0x01, 0x11, 0x11, 0x11, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x11, 0x10, 0x00
   , 0x11, 0x11, 0x11, 0x11, 0x33, 0x33, 0x33, 0x31, 0x11, 0x13, 0x11, 0x11, 0x00
   , 0x11, 0x11, 0x11, 0x11, 0x33, 0x33, 0x33, 0x31, 0x11, 0x13, 0x11, 0x11, 0x10
   , 0x11, 0x11, 0x11, 0x11, 0x33, 0x33, 0x33, 0x31, 0x11, 0x13, 0x11, 0x11, 0x11
   , 0x11, 0x11, 0x11, 0x11, 0x33, 0x33, 0x33, 0x31, 0x11, 0x13, 0x11, 0x11, 0x11
   , 0x11, 0x11, 0x11, 0x11, 0x33, 0x33, 0x33, 0x31, 0x11, 0x13, 0x11, 0x11, 0x11
   , 0x11, 0x11, 0x11, 0x11, 0x33, 0x33, 0x33, 0x31, 0x11, 0x13, 0x11, 0x11, 0x11
   , 0x11, 0x11, 0x11, 0x11, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x11, 0x11, 0x11
   , 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
   , 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
   , 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
   , 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
   , 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
   , 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
   , 0x11, 0x11, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x51, 0x11
   , 0x11, 0x11, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x51, 0x11
   , 0x11, 0x11, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x51, 0x11
   , 0x11, 0x11, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x51, 0x11
   , 0x11, 0x11, 0x55, 0x05, 0x50, 0x00, 0x55, 0x05, 0x50, 0x05, 0x50, 0x51, 0x11
   , 0x11, 0x11, 0x50, 0x50, 0x55, 0x05, 0x50, 0x50, 0x50, 0x50, 0x50, 0x51, 0x11
   , 0x11, 0x11, 0x50, 0x00, 0x55, 0x05, 0x50, 0x00, 0x50, 0x05, 0x50, 0x51, 0x11
   , 0x11, 0x11, 0x50, 0x50, 0x55, 0x05, 0x50, 0x50, 0x50, 0x50, 0x50, 0x51, 0x11
   , 0x11, 0x11, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x51, 0x11
   , 0x10, 0x01, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x51, 0x11
   , 0x10, 0x01, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x51, 0x11
   , 0x01, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10 };
#define DISK7(x, y, buf) { 26, 26, x, y, 0, 0, 0, buf }

const uint8_t inv0[] PROGMEM = { // height=8, width(real image)=12 , width(buffer)=6
     0x00, 0x30, 0x00, 0x00, 0x30, 0x00
   , 0x00, 0x03, 0x00, 0x03, 0x00, 0x00
   , 0x00, 0x33, 0x33, 0x33, 0x30, 0x00
   , 0x03, 0x30, 0x33, 0x30, 0x33, 0x00
   , 0x33, 0x33, 0x33, 0x33, 0x33, 0x30
   , 0x30, 0x33, 0x33, 0x33, 0x30, 0x30
   , 0x30, 0x30, 0x00, 0x00, 0x30, 0x30
   , 0x00, 0x03, 0x30, 0x33, 0x00, 0x00 };
#define INV0(x, y, buf) { 8, 12, x, y, 0, 0, 0, buf }

const uint8_t inv1[] PROGMEM = { // height=8, width(real image)=12 , width(buffer)=6
     0x00, 0x00, 0x66, 0x66, 0x00, 0x00
   , 0x06, 0x66, 0x66, 0x66, 0x66, 0x60
   , 0x66, 0x66, 0x66, 0x66, 0x66, 0x66
   , 0x66, 0x60, 0x06, 0x60, 0x06, 0x66
   , 0x66, 0x66, 0x66, 0x66, 0x66, 0x66
   , 0x00, 0x06, 0x60, 0x06, 0x60, 0x00
   , 0x00, 0x66, 0x06, 0x60, 0x66, 0x00
   , 0x66, 0x00, 0x00, 0x00, 0x00, 0x66 };
#define INV1(x, y, buf) { 8, 12, x, y, 0, 0, 0, buf }

const uint8_t inv2[] PROGMEM = { // height=8, width(real image)=8 , width(buffer)=4
     0x00, 0x05, 0x50, 0x00
   , 0x00, 0x55, 0x55, 0x00
   , 0x05, 0x55, 0x55, 0x50
   , 0x55, 0x05, 0x50, 0x55
   , 0x55, 0x55, 0x55, 0x55
   , 0x00, 0x50, 0x05, 0x00
   , 0x05, 0x05, 0x50, 0x50
   , 0x50, 0x50, 0x05, 0x05 };
#define INV2(x, y, buf) { 8, 8, x, y, 0, 0, 0, buf }

// deal with PROGMEM at runtime, official doc tells to do like this (enum are index of buffers, simplifying implementation, must be the same name as buffer & prefixed by 'E'):
enum                                  { EbufPacL0, EbufPacL1, EbufPacL2, EmonsterLcyan, Ebubble01, Ebubble02, Epotion, Ehero, Ehero1, Edisk7, Einv0, Einv1, Einv2 };
const uint8_t* const data[] PROGMEM = {  bufPacL0,  bufPacL1,  bufPacL2,  monsterLcyan,  bubble01,  bubble02,  potion,  hero,  hero1,  disk7,  inv0,  inv1,  inv2 };

struct Obj { uint8_t h; uint8_t w; int16_t x; int16_t y; int16_t pX; int16_t pY1; int16_t pY2; const uint8_t* buf; }; // w is "real" sprite width, array (cols) is w/2 because 1 byte for 2 pixel in buffer
uint8_t NBSPR = 2;  // must be <= obj size, see above examples
Obj obj[2];         // hold and display maximumu 2 sprites at a time
uint8_t buf0[348]; uint8_t buf1[348]; uint8_t buf2[348]; uint8_t buf3[348]; // 4 buffers in RAM to read sprites from PROGMEM, max sprite size is 29x24 (29x12 bytes in memory) or equivalent
//-------------------------------------------------------------------------------------------
void setup() 
{   SETO(A0, LOW); SETO(A1, LOW); SETO(A2, LOW); SETO(A3, LOW);     // A0-A3 as output
    SETO(OE, HIGH); SETO(LAT, LOW); SETO(CLK, LOW);                 // LAT & OE as output, R1 & SCK too
    SETO(CR1, LOW); SETO(CG1, LOW); SETO(CB1, LOW); SETO(CR2, LOW); SETO(CG2, LOW); SETO(CB2, LOW);
}
//-------------------------------------------------------------------------------------------
void drawSprite()
{   uint8_t s = 0; uint8_t panelPixel1 = 0; uint8_t panelPixel2 = 0; uint8_t pix; Obj* o;
    uint8_t sY1; uint8_t sY2; // sprite index in obj when pixel found
    for (uint8_t row = 0; row < PANEL_HEIGHT_HALF; ++row)
    {   for (s = 0; s < NBSPR; ++s)
        {   obj[s].pY1 = row - obj[s].y;
            obj[s].pY2 = (row + PANEL_HEIGHT_HALF) - obj[s].y;
        }            
        for (uint8_t col = 0; col < PANEL_WIDTH; ++col)
        {   sY1 = sY2 = 0xFF;
            for (s = 0; s < NBSPR; ++s) 
            {   o = &obj[s];
                o->pX = col - o->x;   // compute pixel positions relative to the sprite's top-left corner
                if (o->pX >= 0 && o->pX < o->w)
                {   if (o->pY1 >= 0 && o->pY1 < o->h) { sY1 = s; } // current sprite in top half ?
                    if (o->pY2 >= 0 && o->pY2 < o->h) { sY2 = s; } // current sprite in bottom half ?
                }
            }

            if (sY1 != 0xFF)
            {   o = &obj[sY1];
                pix = o->buf[(o->pY1 * (o->w >> 1)) + (o->pX >> 1)];  // retrieve pixel byte
                if ((o->pX & 0x01) == 0) { pix >>= 4; }               // check if MSB or LSB quartet, if MSB then transfert to LSB
                OUT(CR1, pix & 0x04); OUT(CG1, pix & 0x02); OUT(CB1, pix & 0x01);
//                if ((o->pX & 0x01) == 0) { OUT(CR1, pix & 0x40); OUT(CG1, pix & 0x20); OUT(CB1, pix & 0x10); }               // check if MSB or LSB quartet, if MSB then transfert to LSB
//                else { OUT(CR1, pix & 0x04); OUT(CG1, pix & 0x02); OUT(CB1, pix & 0x01); }
            }
            else { OUT0(CR1); OUT0(CG1); OUT0(CB1); }

            if (sY2 != 0xFF)
            {   o = &obj[sY2];
                pix = o->buf[(o->pY2 * (o->w >> 1)) + (o->pX >> 1)];
                if ((o->pX & 0x01) == 0) { pix >>= 4; }
                OUT(CR2, pix & 0x04); OUT(CG2, pix & 0x02); OUT(CB2, pix & 0x01);
//                if ((o->pX & 0x01) == 0) { OUT(CR2, pix & 0x40); OUT(CG2, pix & 0x20); OUT(CB2, pix & 0x10); }
//                else { OUT(CR2, pix & 0x04); OUT(CG2, pix & 0x02); OUT(CB2, pix & 0x01); }

            }
            else { OUT0(CR2); OUT0(CG2); OUT0(CB2); }

            OUT1(CLK); OUT0(CLK);
        }
        OUT1(OE);     // deactivate display
        OUT1(LAT);    // transfert shift registers to display buffer
        OUT0(LAT);    // lock register
        PORTC = ((PORTC & 0xF0) | row); // select line A3~A0, 4 MSB bits remain unchanged
        OUT0(OE);     // activate display
//        delayMicroseconds(50);
    }
}
//-------------------------------------------------------------------------------------------
#define LOADBUF(to, from) { const uint8_t* d = (const uint8_t*)pgm_read_ptr(&data[E##from]); \
                            for (uint16_t i = 0; i < sizeof(from); ++i) { to[i] = pgm_read_byte(&d[i]); } }
//-------------------------------------------------------------------------------------------
uint32_t tNow; uint32_t tEnd; uint32_t tEndMov = 0; uint32_t tEndAnim = 0; // timing management
#define TANIM 20 // ms
//-------------------------------------------------------------------------------------------

//#define BUBBL1 drwSprite(); --obj[0].x; --obj[1].x; --obj[2].x;

void loop()
{   // pacman
    NBSPR = 2;
    LOADBUF(buf0, bufPacL0); LOADBUF(buf1, bufPacL1); LOADBUF(buf2, bufPacL2); // load 3 sprites for animation
    LOADBUF(buf3, monsterLcyan);
    obj[0] = BUFPACL0(150, 9, buf0);
    obj[1] = MONSTERLCYAN(200, 9, buf3);
    uint8_t* seq[] = { buf0, buf1, buf2, buf1 };
    int8_t idx = 0;
    while (true)
    {   drawSprite();
        tNow = millis();
        if (tNow > tEndMov)                 // pac movement 
        {   --obj[0].x;
            --obj[1].x; if (obj[1].x < -50) { break; }
            tEndMov = tNow + TANIM;         // evry TANIM ms
            if (tNow > tEndAnim)            // pac mouth anim
            {   obj[0].buf = seq[idx];      // change sprite for animation
                idx = (idx + 1) % 4;        // here seq size is 4
                tEndAnim = tNow + 60;       // every 60 ms
            }
        }
    }

    // bubble 
    NBSPR = 3;
    LOADBUF(buf0, bubble01); LOADBUF(buf1, bubble02);
    obj[0] = BUBBLE01(150, 16, buf0);
    obj[1] = BUBBLE01(200, 0, buf0);
    obj[2] = BUBBLE02(250, 16, buf1);
    while (true)
    {   drawSprite();
//        tNow = millis();
//        if (tNow > tEndMov)
        {   --obj[0].x;
            --obj[1].x;
            --obj[2].x; if (obj[2].x < -50) { break; }
//            tEndMov = tNow + TANIM;
        }
    }

    // potion 
    NBSPR = 1;
    LOADBUF(buf0, potion);
    obj[0] = POTION(150, 2, buf0);
    while (true)
    {   drawSprite();
        tNow = millis();
        if (tNow > tEndMov)
        {   --obj[0].x; if (obj[0].x < -50) { break; }
            tEndMov = tNow + TANIM;
        }
    }

    // hero
    NBSPR = 1;
    LOADBUF(buf0, hero); LOADBUF(buf1, hero1)
    obj[0] = HERO(150, 9, buf0);
    seq[0] = buf0; seq[1] = buf1;
    idx = 0;
    while (true)
    {   drawSprite();
        tNow = millis();
        if (tNow > tEndMov)
        {   --obj[0].x; if (obj[0].x < -50) { break; }
            tEndMov = tNow + TANIM;
            if (tNow > tEndAnim)            // animation
            {   obj[0].buf = seq[idx];      // change sprite for animation
                idx = (idx + 1) % 2;
                tEndAnim = tNow + 60;       // every 60 ms
            }
        }
    }

    // disk7
    NBSPR = 1;
    LOADBUF(buf0, disk7);
    obj[0] = DISK7(160, 2, buf0);
    while (true)
    {   drawSprite();
        tNow = millis();
        if (tNow > tEndMov)
        {   --obj[0].x; if (obj[0].x < -50) { break; }
            tEndMov = tNow + TANIM;
        }
    }

    // invaders
    NBSPR = 3;
    LOADBUF(buf0, inv0); LOADBUF(buf1, inv1); LOADBUF(buf2, inv2);
    obj[0] = INV0(160, 3, buf0);
    obj[1] = INV1(300, 12, buf1);
    obj[2] = INV2(200, 21, buf2);
    while (true)
    {   drawSprite();
        tNow = millis();
        if (tNow > tEndMov)
        {   --obj[0].x;
            obj[1].x -= 2;
            --obj[2].x; if (obj[2].x < -50) { break; }
            tEndMov = tNow + TANIM;
        }
    }
}
